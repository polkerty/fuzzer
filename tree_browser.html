<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Postgres Issue Explorer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #folderPrompt {
      background-color: #f0f0f0;
      padding: 15px;
      border-bottom: 1px solid #ccc;
    }
    #main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    #sidebar {
      width: 300px;
      background-color: #f5f5f5;
      border-right: 1px solid #ddd;
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
    }
    /* Count of filtered items */
    #itemCount {
      font-size: 0.9em;
      margin-bottom: 10px;
      font-weight: bold;
    }
    #filterPanel {
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #ccc;
    }
    #filterPanel label {
      display: block;
      margin-top: 5px;
      font-size: 0.9em;
    }
    #filterPanel input {
      width: 100%;
      padding: 4px;
      margin-top: 2px;
      box-sizing: border-box;
    }
    #filterPanel button {
      margin-top: 8px;
      margin-right: 5px;
      padding: 5px 10px;
      font-size: 0.9em;
    }
    #issueList {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    #issueList li {
      padding: 10px;
      cursor: pointer;
      border-bottom: 1px solid #ddd;
      /* Default background if no type */
      background-color: #e0e0e0;
    }
    #issueList li:hover {
      opacity: 0.9;
    }
    /* When active, add a border */
    #issueList li.active {
      border: 2px solid #000;
    }
    #content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }
    pre {
      background-color: #eee;
      padding: 10px;
      overflow: auto;
      white-space: pre-wrap; /* preserves multi-line formatting */
    }
    .nav-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
    }
    a {
      color: #007BFF;
      text-decoration: none;
    }
    h2, h3 {
      margin-top: 0;
    }
    /* Tabs for source code viewer */
    #tabsContainer {
      border-bottom: 1px solid #ccc;
      margin-bottom: 10px;
    }
    #tabsList {
      list-style-type: none;
      padding: 0;
      margin: 0;
      display: flex;
      flex-wrap: wrap; /* allows wrapping */
    }
    #tabsList li {
      padding: 8px 12px;
      cursor: pointer;
      border: 1px solid #ccc;
      border-bottom: none;
      margin-right: 5px;
      background-color: #f0f0f0;
    }
    #tabsList li.active {
      background-color: #fff;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div id="folderPrompt">
    <p>Select the folder containing your issue JSON files:</p>
    <input type="file" id="folderInput" webkitdirectory directory multiple>
  </div>
  <div id="main" style="display:none;">
    <div id="sidebar">
      <!-- Filter panel -->
      <div id="filterPanel">
        <h4>Filters</h4>
        <label for="typeFilter">Analysis Type:</label>
        <input type="text" id="typeFilter" placeholder="e.g., TYPO">
        
        <label for="minConfidence">Minimum Confidence:</label>
        <input type="number" id="minConfidence" placeholder="e.g., 0">
        
        <label for="minSeverity">Minimum Severity:</label>
        <input type="number" id="minSeverity" placeholder="e.g., 0">
        
        <button id="applyFilters">Apply Filters</button>
        <button id="clearFilters">Clear Filters</button>
      </div>
      <!-- Count of filtered issues -->
      <div id="itemCount"></div>
      <ul id="issueList">
        <!-- Issues will be loaded here -->
      </ul>
    </div>
    <div id="content">
      <!-- Analysis section at the top -->
      <h3>Analysis</h3>
      <pre id="analysis"></pre>
      
      <!-- Tabbed source code viewer -->
      <h2 id="functionName">Function Name</h2>
      <p>
        <strong>File:</strong>
        <a id="sourceLink" href="#" target="_blank">Source File</a>
      </p>
      <div id="tabsContainer">
        <ul id="tabsList">
          <!-- Tabs will be dynamically populated -->
        </ul>
      </div>
      <h3>Source Code</h3>
      <pre id="sourceCode"></pre>
      
      <div class="nav-buttons">
        <button id="prevBtn">Previous</button>
        <button id="nextBtn">Next</button>
      </div>
    </div>
  </div>
  <script>
    let issues = [];
    let filteredIssues = [];
    let currentIndex = 0;
    let currentFunctionIndex = 0; // index of currently selected function tab in the issue

    // Mapping analysis types to colors.
    function getColorForType(type) {
      if (!type) return "#e0e0e0";
      switch (type.toUpperCase()) {
        case "TYPO":
          return "#ffcccc"; // light red
        case "LOGIC":
          return "#ccffcc"; // light green
        case "PERFORMANCE":
          return "#ccccff"; // light blue
        default:
          return "#e0e0e0"; // default grey
      }
    }
    
    // Converts a local file path (from the JSON) to a GitHub URL.
    function convertPathToGitHubLink(filePath) {
      // Adjust based on your repository layout.
      const marker = "/postgres/postgres/";
      const index = filePath.indexOf(marker);
      if (index !== -1) {
        return "https://github.com/postgres/postgres/blob/master/" + filePath.substring(index + marker.length);
      }
      return "#";
    }

    // Loads a function's details (for the tabbed source code viewer).
    function loadFunctionTab(fnObj) {
      document.getElementById('functionName').innerText = fnObj.functionName;
      document.getElementById('sourceCode').innerText = fnObj.source;
      
      const githubLink = convertPathToGitHubLink(fnObj.file);
      const linkElem = document.getElementById('sourceLink');
      linkElem.href = githubLink;
      linkElem.innerText = fnObj.file;
    }

    // Populates the tabs for the source code viewer.
    function populateTabs(allFunctions) {
      const tabsList = document.getElementById('tabsList');
      tabsList.innerHTML = "";
      allFunctions.forEach((fn, index) => {
        const li = document.createElement('li');
        li.innerText = fn.functionName;
        li.addEventListener('click', () => {
          currentFunctionIndex = index;
          document.querySelectorAll('#tabsList li').forEach((tab, idx) => {
            tab.classList.toggle('active', idx === index);
          });
          loadFunctionTab(fn);
        });
        tabsList.appendChild(li);
      });
      // Set first tab active by default.
      if (allFunctions.length > 0) {
        document.querySelectorAll('#tabsList li')[0].classList.add('active');
      }
    }

    // Loads a single issue into the content area.
    function loadIssue(index) {
      const issue = filteredIssues[index];
      // Format analysis entries.
      document.getElementById('analysis').innerText = issue.analysis
        .map(a => 
          `Type: ${a.type}\nConfidence: ${a.confidence}\nSeverity: ${a.severity}\nDescription: ${a.description}`
        )
        .join("\n\n");
      
      // Build an array of functions: top-level function from tree and any called functions.
      const allFunctions = [];
      // Top-level function.
      allFunctions.push({
        functionName: issue.tree.functionName,
        source: issue.tree.source,
        file: issue.tree.file
      });
      // Called functions.
      if (issue.tree.calledFunctions && Array.isArray(issue.tree.calledFunctions)) {
        issue.tree.calledFunctions.forEach(fn => {
          allFunctions.push({
            functionName: fn.functionName,
            source: fn.source,
            file: fn.file
          });
        });
      }
      currentFunctionIndex = 0;
      populateTabs(allFunctions);
      if (allFunctions.length > 0) {
        loadFunctionTab(allFunctions[0]);
      }
    }

    // Populates the sidebar using filteredIssues and updates the count.
    function populateSidebar() {
      const list = document.getElementById('issueList');
      list.innerHTML = "";
      filteredIssues.forEach((issue, index) => {
        const li = document.createElement('li');
        // Use the first analysis entry's type to determine color.
        const analysisType = (issue.analysis && issue.analysis.length > 0) ? issue.analysis[0].type : "";
        li.style.backgroundColor = getColorForType(analysisType);
        const fileName = issue.tree.file.split('/').pop();
        li.innerText = issue.tree.functionName + " (" + fileName + ")";
        li.addEventListener('click', () => {
          currentIndex = index;
          loadIssue(currentIndex);
          // Mark the active item.
          document.querySelectorAll('#issueList li').forEach((item, idx) => {
            item.classList.toggle('active', idx === index);
          });
        });
        list.appendChild(li);
      });
      // Update count display.
      document.getElementById('itemCount').innerText = `Total items: ${filteredIssues.length}`;
    }

    // Applies filters based on analysis type, min confidence, and min severity.
    function applyFilters() {
      const typeFilter = document.getElementById("typeFilter").value.trim();
      const minConfidenceStr = document.getElementById("minConfidence").value;
      const minSeverityStr = document.getElementById("minSeverity").value;
      const minConfidence = minConfidenceStr ? parseFloat(minConfidenceStr) : null;
      const minSeverity = minSeverityStr ? parseFloat(minSeverityStr) : null;
      
      filteredIssues = issues.filter(issue => {
        // Include the issue if at least one analysis entry matches all filters.
        return issue.analysis.some(a => {
          let match = true;
          if (typeFilter) {
            match = match && a.type.toLowerCase().includes(typeFilter.toLowerCase());
          }
          if (minConfidence !== null) {
            match = match && (a.confidence >= minConfidence);
          }
          if (minSeverity !== null) {
            match = match && (a.severity >= minSeverity);
          }
          return match;
        });
      });
      currentIndex = 0;
      populateSidebar();
      if (filteredIssues.length > 0) {
        loadIssue(0);
      } else {
        document.getElementById("functionName").innerText = "";
        document.getElementById("sourceCode").innerText = "";
        document.getElementById("analysis").innerText = "No issues match the filters.";
        document.getElementById("sourceLink").innerText = "";
        document.getElementById("sourceLink").href = "#";
        document.getElementById("tabsList").innerHTML = "";
      }
    }

    // Clears all filters.
    function clearFilters() {
      document.getElementById("typeFilter").value = "";
      document.getElementById("minConfidence").value = "";
      document.getElementById("minSeverity").value = "";
      filteredIssues = issues.slice();
      currentIndex = 0;
      populateSidebar();
      if (filteredIssues.length > 0) {
        loadIssue(0);
      }
    }

    // Handle folder selection.
    document.getElementById('folderInput').addEventListener('change', async (event) => {
      const files = event.target.files;
      // Load all JSON files.
      const jsonFiles = Array.from(files).filter(file => file.name.endsWith('.json'));

      if (jsonFiles.length === 0) {
        alert("No JSON files found in this folder.");
        return;
      }

      // Read and parse each JSON file.
      const readFile = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            resolve(JSON.parse(e.target.result));
          } catch (err) {
            console.error("Error parsing JSON in", file.name, err);
            resolve(null);
          }
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });

      const promises = jsonFiles.map(file => readFile(file));
      const results = await Promise.all(promises);
      issues = results.filter(issue => issue !== null);

      if (issues.length === 0) {
        alert("No valid issue JSON files found.");
        return;
      }

      // Initialize filteredIssues to include all issues.
      filteredIssues = issues.slice();

      // Hide the folder prompt and show the main interface.
      document.getElementById('folderPrompt').style.display = 'none';
      document.getElementById('main').style.display = 'flex';

      populateSidebar();
      loadIssue(0);
    });

    // Navigation buttons.
    document.getElementById('prevBtn').addEventListener('click', () => {
      if (currentIndex > 0) {
        currentIndex--;
        loadIssue(currentIndex);
      }
    });
    document.getElementById('nextBtn').addEventListener('click', () => {
      if (currentIndex < filteredIssues.length - 1) {
        currentIndex++;
        loadIssue(currentIndex);
      }
    });

    // Filter buttons.
    document.getElementById('applyFilters').addEventListener('click', applyFilters);
    document.getElementById('clearFilters').addEventListener('click', clearFilters);
  </script>
</body>
</html>
