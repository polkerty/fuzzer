<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Postgres Issue Explorer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    #folderPrompt {
      background-color: #f0f0f0;
      padding: 15px;
      border-bottom: 1px solid #ccc;
    }
    #main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }
    #sidebar {
      width: 300px;
      background-color: #f5f5f5;
      border-right: 1px solid #ddd;
      overflow-y: auto;
      padding: 10px;
      box-sizing: border-box;
    }
    #filterPanel {
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid #ccc;
    }
    #filterPanel label {
      display: block;
      margin-top: 5px;
      font-size: 0.9em;
    }
    #filterPanel input {
      width: 100%;
      padding: 4px;
      margin-top: 2px;
      box-sizing: border-box;
    }
    #filterPanel button {
      margin-top: 8px;
      margin-right: 5px;
      padding: 5px 10px;
      font-size: 0.9em;
    }
    #issueList {
      list-style-type: none;
      padding: 0;
      margin: 0;
    }
    #issueList li {
      padding: 10px;
      cursor: pointer;
      border-bottom: 1px solid #ddd;
    }
    #issueList li:hover {
      background-color: #e0e0e0;
    }
    #content {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }
    pre {
      background-color: #eee;
      padding: 10px;
      overflow: auto;
      white-space: pre-wrap; /* preserves multi-line formatting */
    }
    .nav-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: space-between;
    }
    a {
      color: #007BFF;
      text-decoration: none;
    }
    h2, h3 {
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div id="folderPrompt">
    <p>Select the folder containing your issue JSON files:</p>
    <input type="file" id="folderInput" webkitdirectory directory multiple>
  </div>
  <div id="main" style="display:none;">
    <div id="sidebar">
      <!-- Filter panel -->
      <div id="filterPanel">
        <h4>Filters</h4>
        <label for="typeFilter">Analysis Type:</label>
        <input type="text" id="typeFilter" placeholder="e.g., TYPO">
        
        <label for="minConfidence">Minimum Confidence:</label>
        <input type="number" id="minConfidence" placeholder="e.g., 0">
        
        <label for="minSeverity">Minimum Severity:</label>
        <input type="number" id="minSeverity" placeholder="e.g., 0">
        
        <button id="applyFilters">Apply Filters</button>
        <button id="clearFilters">Clear Filters</button>
      </div>
      <ul id="issueList">
        <!-- Issues will be loaded here -->
      </ul>
    </div>
    <div id="content">
      <!-- Analysis section moved to the top -->
      <h3>Analysis</h3>
      <pre id="analysis"></pre>
      <h2 id="functionName">Function Name</h2>
      <p>
        <strong>File:</strong>
        <a id="sourceLink" href="#" target="_blank">Source File</a>
      </p>
      <h3>Source Code</h3>
      <pre id="sourceCode"></pre>
      <div class="nav-buttons">
        <button id="prevBtn">Previous</button>
        <button id="nextBtn">Next</button>
      </div>
    </div>
  </div>
  <script>
    let issues = [];
    let filteredIssues = [];
    let currentIndex = 0;
    
    // Converts a local file path (from the JSON) to a GitHub URL.
    function convertPathToGitHubLink(filePath) {
      // Adjust based on your repository layout.
      const marker = "/postgres/postgres/";
      const index = filePath.indexOf(marker);
      if (index !== -1) {
        return "https://github.com/postgres/postgres/blob/master/" + filePath.substring(index + marker.length);
      }
      return "#";
    }

    // Loads a single issue into the content area.
    function loadIssue(index) {
      const issue = filteredIssues[index];
      document.getElementById('functionName').innerText = issue.tree.functionName;
      document.getElementById('sourceCode').innerText = issue.tree.source;
      
      // Format each analysis entry for readability.
      document.getElementById('analysis').innerText = issue.analysis
        .map(a => 
          `Type: ${a.type}\nConfidence: ${a.confidence}\nSeverity: ${a.severity}\nDescription: ${a.description}`
        )
        .join("\n\n");
      
      const githubLink = convertPathToGitHubLink(issue.tree.file);
      const linkElem = document.getElementById('sourceLink');
      linkElem.href = githubLink;
      linkElem.innerText = issue.tree.file;

      // Highlight the selected item in the sidebar.
      const items = document.querySelectorAll('#issueList li');
      items.forEach((item, idx) => {
        item.style.backgroundColor = (idx === index) ? '#ddd' : '';
      });
    }

    // Populates the sidebar using filteredIssues.
    function populateSidebar() {
      const list = document.getElementById('issueList');
      list.innerHTML = "";
      filteredIssues.forEach((issue, index) => {
        const li = document.createElement('li');
        const fileName = issue.tree.file.split('/').pop();
        li.innerText = issue.tree.functionName + " (" + fileName + ")";
        li.addEventListener('click', () => {
          currentIndex = index;
          loadIssue(currentIndex);
        });
        list.appendChild(li);
      });
    }

    // Applies filters based on analysis type, min confidence, and min severity.
    function applyFilters() {
      const typeFilter = document.getElementById("typeFilter").value.trim();
      const minConfidenceStr = document.getElementById("minConfidence").value;
      const minSeverityStr = document.getElementById("minSeverity").value;
      const minConfidence = minConfidenceStr ? parseFloat(minConfidenceStr) : null;
      const minSeverity = minSeverityStr ? parseFloat(minSeverityStr) : null;
      
      filteredIssues = issues.filter(issue => {
        // An issue is included if at least one analysis entry matches all the filters.
        return issue.analysis.some(a => {
          let match = true;
          if (typeFilter) {
            match = match && a.type.toLowerCase().includes(typeFilter.toLowerCase());
          }
          if (minConfidence !== null) {
            match = match && (a.confidence >= minConfidence);
          }
          if (minSeverity !== null) {
            match = match && (a.severity >= minSeverity);
          }
          return match;
        });
      });
      currentIndex = 0;
      populateSidebar();
      if (filteredIssues.length > 0) {
        loadIssue(0);
      } else {
        // Clear the content area if no issues match.
        document.getElementById("functionName").innerText = "";
        document.getElementById("sourceCode").innerText = "";
        document.getElementById("analysis").innerText = "No issues match the filters.";
        document.getElementById("sourceLink").innerText = "";
        document.getElementById("sourceLink").href = "#";
      }
    }

    // Clears all filters.
    function clearFilters() {
      document.getElementById("typeFilter").value = "";
      document.getElementById("minConfidence").value = "";
      document.getElementById("minSeverity").value = "";
      filteredIssues = issues.slice();
      currentIndex = 0;
      populateSidebar();
      if (filteredIssues.length > 0) {
        loadIssue(0);
      }
    }

    // Handle folder selection.
    document.getElementById('folderInput').addEventListener('change', async (event) => {
      const files = event.target.files;
      // Load all JSON files.
      const jsonFiles = Array.from(files).filter(file => file.name.endsWith('.json'));

      if (jsonFiles.length === 0) {
        alert("No JSON files found in this folder.");
        return;
      }

      // Read and parse each JSON file.
      const readFile = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            resolve(JSON.parse(e.target.result));
          } catch (err) {
            console.error("Error parsing JSON in", file.name, err);
            resolve(null);
          }
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });

      const promises = jsonFiles.map(file => readFile(file));
      const results = await Promise.all(promises);
      issues = results.filter(issue => issue !== null);

      if (issues.length === 0) {
        alert("No valid issue JSON files found.");
        return;
      }

      // Initialize filteredIssues to include all issues.
      filteredIssues = issues.slice();

      // Hide the folder prompt and show the main interface.
      document.getElementById('folderPrompt').style.display = 'none';
      document.getElementById('main').style.display = 'flex';

      populateSidebar();
      loadIssue(0);
    });

    // Navigation buttons.
    document.getElementById('prevBtn').addEventListener('click', () => {
      if (currentIndex > 0) {
        currentIndex--;
        loadIssue(currentIndex);
      }
    });
    document.getElementById('nextBtn').addEventListener('click', () => {
      if (currentIndex < filteredIssues.length - 1) {
        currentIndex++;
        loadIssue(currentIndex);
      }
    });

    // Filter buttons.
    document.getElementById('applyFilters').addEventListener('click', applyFilters);
    document.getElementById('clearFilters').addEventListener('click', clearFilters);
  </script>
</body>
</html>
